---
title: Input/Output
sidebar:
  order: 15
slug: computer-architecture/io
prev: true
next: true
---

### Keyboard and Monitor

Primary human-computer interaction devices.

- Keyboard: sends characters (each encoded in 7-bit ASCII).
  - Types:
    - Printable (letters, digits, symbols)
    - Control (non-printable; e.g., carriage return, backspace)

- Monitor: displays output from the system.
  - CLI: text-based interaction.
  - GUI: graphical interaction via mouse & windows.

## I/O Module

A hardware interface that connects the CPU and memory with external devices. Acts as a translator and controller, managing the flow of data, control signals, and status information.

Handles timing, buffering, device-specific communication, and error detection.

Categories:

- Human-readable – monitor, printer.
- Machine-readable – disks, sensors, actuators.
- Communication – remote devices, other computers.

## I/O Commands

| Type    | Purpose                                   |
| ------- | ----------------------------------------- |
| Control | Activate peripheral, define action        |
| Test    | Check device status                       |
| Read    | Move data from peripheral → module buffer |
| Write   | Move data from bus → peripheral           |

## Types of I/O Operations

### Programmed I/O

CPU [polls](/operating-systems/io-systems/#polling) the devices repeatedly and waits until the operation is complete. Simple to implement (no extra interrupt hardware or handlers required). Predictable control flow and timing.
Wastes clock cycles.

Typical sequence:

- CPU issues a command to the I/O device.
- CPU repeatedly reads the device status (polls).
- When status shows "ready" or "data available," CPU performs the read or write.
- CPU continues with other work (or repeats polling) after the transfer.

### Interrupt-driven I/O

CPU continues its operation. When the I/O device is ready, it [interrupts](/operating-systems/io-systems/#interrupts) the CPU. Saves the current context (to the stack), handles the interrupt, restores the context (from the stack), and resumes execution. More efficient than programmed I/O. Requires special hardware. 

### Direct Memory Access

Aka. DMA. Data transferred between memory and I/O device directly. Avoids dependending on the CPU. Special instructions to control the DMA.

## I/O Addressing

Refers to how a computer identifies and communicates with I/O devices.

Each I/O device is assigned a unique address or range of addresses. CPU uses these address(es) to communicate with the device.

### Memory-Mapped

I/O devices share the same address space as the system memory. Instructions used for memory access can also access I/O devices. Simplifies design. Usually faster, and easy to program. Reduces the total memory address range available for RAM. Preferred in modern processors.

### I/O Mapped

Aka. isolated I/O or port mapped. I/O devices have a separate address space. Special I/O instructions (like Intel's `IN`, `OUT`) are used to communicate with peripherals. This keeps memory and I/O addresses distinct but requires extra instructions and control logic.

## General Purpose I/O Port (Example: PIC16F877)

- Configurable for:
  - Digital input/output
  - Analog input/output

- Controlled using special function registers.
- Must be configured for intended function before use.

## Device Identification (Interrupt Handling)

**Methods:**

1. **Multiple interrupt lines** – each module has dedicated line.
2. **Software poll** – CPU checks modules sequentially (slow).
3. **Daisy chain (hardware poll)** – modules connected in chain; first ready device handles.
4. **Vectored interrupt** – device sends vector (address of its service routine).
5. **Bus arbitration** – device must first control bus to request interrupt.

## Drawbacks of Programmed / Interrupt I/O

1. Limited by CPU speed.
2. CPU time wasted managing I/O.
   → **Solution:** Direct Memory Access (DMA).

## DMA Operation

**Idea:** I/O module moves data directly between device and memory.

- CPU initiates DMA and gets interrupt after completion.
- Frees CPU for other processing.
- Requires bus arbitration (DMA controller competes for system bus).

## Evolution of I/O Function

1. CPU directly controls device.
2. I/O controller added – **programmed I/O**.
3. **Interrupts** introduced – more efficient.
4. **DMA** added – block transfer without CPU.
5. I/O module becomes **processor-like** (own instruction set).
6. I/O module gains **local memory** → acts as mini-computer (e.g., GPU).

## I/O Channel Architecture

- Specialized processors managing multiple I/O devices.
- Example: **PCIe architecture**
  - Uses **root complex** (chipset).
  - Supports device-to-device communication (not just CPU-to-device).

## External Interconnection Standards

| Type      | Examples                                 |
| --------- | ---------------------------------------- |
| Parallel  | Parallel port, IDE                       |
| Serial    | Serial port, SATA, SCSI, USB             |
| Bus-based | PCI, PCIe                                |
| Network   | Ethernet, Wi-Fi, Thunderbolt, Infiniband |

## Summary

- **External devices:** keyboard, monitor, disk.
- **I/O modules:** control, data, status handling.
- **I/O Techniques:** programmed, interrupt, DMA.
- **Advanced concepts:** I/O channels, bus systems, interconnection standards.
